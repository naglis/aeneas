# aeneas is a Python/C library and a set of tools
# to automagically synchronize audio and text (aka forced alignment)
#
# Copyright (C) 2012-2013, Alberto Pettarin (www.albertopettarin.it)
# Copyright (C) 2013-2015, ReadBeyond Srl   (www.readbeyond.it)
# Copyright (C) 2015-2017, Alberto Pettarin (www.albertopettarin.it)
#
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU Affero General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU Affero General Public License for more details.
#
# You should have received a copy of the GNU Affero General Public License
# along with this program.  If not, see <http://www.gnu.org/licenses/>.

"""
This module contains the following classes:

* :class:`~aeneas.synthesizer.Synthesizer`,
  for synthesizing text fragments into an audio file,
  along with the corresponding time anchors.

.. warning:: This module might be refactored in a future version
"""

import importlib.util
import logging
import os.path

from aeneas.logger import Configurable
from aeneas.runtimeconfiguration import RuntimeConfiguration
from aeneas.textfile import TextFile
from aeneas.ttswrappers.espeakngttswrapper import ESPEAKNGTTSWrapper
from aeneas.ttswrappers.espeakttswrapper import ESPEAKTTSWrapper
from aeneas.ttswrappers.festivalttswrapper import FESTIVALTTSWrapper
from aeneas.ttswrappers.nuancettswrapper import NuanceTTSWrapper

logger = logging.getLogger(__name__)


class Synthesizer(Configurable):
    """
    A class to synthesize text fragments into
    an audio file,
    along with the corresponding time anchors.

    :param rconf: a runtime configuration
    :type  rconf: :class:`~aeneas.runtimeconfiguration.RuntimeConfiguration`
    :raises: OSError: if a custom TTS engine is requested
                      but it cannot be loaded
    :raises: ImportError: if the Nuance TTS API wrapper is requested
                          but the``requests`` module is not installed
    """

    ESPEAK = "espeak"
    """ Select eSpeak wrapper """

    ESPEAKNG = "espeak-ng"
    """ Select eSpeak NG wrapper """

    FESTIVAL = "festival"
    """ Select Festival wrapper """

    NUANCE = "nuance"
    """ Select Nuance TTS API wrapper """

    ALLOWED_VALUES = [ESPEAK, ESPEAKNG, FESTIVAL, NUANCE]
    """ List of all the allowed values """

    def __init__(self, rconf=None):
        super().__init__(rconf=rconf)
        self.tts_engine = None
        self._select_tts_engine()

    def _select_tts_engine(self):
        """
        Select the TTS engine to be used by looking at the rconf object.
        """
        logger.debug("Selecting TTS engine...")
        requested_tts_engine = self.rconf[RuntimeConfiguration.TTS]
        tts_cls = None
        match requested_tts_engine:
            case self.NUANCE:
                if importlib.util.find_spec("requests") is None:
                    raise ImportError(
                        "Unable to import requests for Nuance TTS API wrapper"
                    )
                tts_cls = NuanceTTSWrapper
            case self.ESPEAK:
                tts_cls = ESPEAKTTSWrapper
            case self.ESPEAKNG:
                tts_cls = ESPEAKNGTTSWrapper
            case self.FESTIVAL:
                tts_cls = FESTIVALTTSWrapper
            case _ as other:
                raise ValueError(f"Invalid TTS engine type {other!r}")

        logger.debug("Creating %r instance...", tts_cls.__name__)
        self.tts_engine = tts_cls(rconf=self.rconf)
        logger.debug("Creating %r instance... done", tts_cls.__name__)
        logger.debug("Selecting TTS engine... done")

    @property
    def output_audio_format(self):
        """
        Return a tuple ``(codec, channels, rate)``
        specifying the audio format
        generated by the actual TTS engine.

        :rtype: tuple
        """
        if self.tts_engine is not None:
            return self.tts_engine.OUTPUT_AUDIO_FORMAT
        return None

    def clear_cache(self):
        """
        Clear the TTS cache, removing all cache files from disk.

        .. versionadded:: 1.6.0
        """
        if self.tts_engine is not None:
            self.tts_engine.clear_cache()

    def synthesize(
        self,
        text_file: TextFile,
        audio_file_path: str,
        quit_after=None,
        backwards=False,
    ):
        """
        Synthesize the text contained in the given fragment list
        into a ``wav`` file.

        Return a tuple ``(anchors, total_time, num_chars)``.

        :param text_file: the text file to be synthesized
        :type  text_file: :class:`~aeneas.textfile.TextFile`
        :param string audio_file_path: the path to the output audio file
        :param float quit_after: stop synthesizing as soon as
                                 reaching this many seconds
        :param bool backwards: if ``True``, synthesizing from the end of the text file
        :rtype: tuple
        :raises: TypeError: if ``text_file`` is ``None`` or not an instance of ``TextFile``
        :raises: OSError: if ``tts=custom`` in the RuntimeConfiguration and ``tts_path`` cannot be read
        :raises: ValueError: if the TTS engine has not been set yet
        """
        if text_file is None:
            raise TypeError("`text_file` is None")
        if not isinstance(text_file, TextFile):
            raise TypeError("`text_file` is not an instance of TextFile")
        if self.tts_engine is None:
            raise ValueError("Cannot select the TTS engine")

        # synthesize
        logger.debug("Synthesizing text...")
        result = self.tts_engine.synthesize_multiple(
            text_file=text_file,
            output_file_path=audio_file_path,
            quit_after=quit_after,
            backwards=backwards,
        )
        logger.debug("Synthesizing text... done")

        # check that the output file has been written
        if not os.path.isfile(audio_file_path):
            raise OSError(f"Audio file path {audio_file_path!r} cannot be read")

        return result
