# aeneas is a Python/C library and a set of tools
# to automagically synchronize audio and text (aka forced alignment)
#
# Copyright (C) 2012-2013, Alberto Pettarin (www.albertopettarin.it)
# Copyright (C) 2013-2015, ReadBeyond Srl   (www.readbeyond.it)
# Copyright (C) 2015-2017, Alberto Pettarin (www.albertopettarin.it)
#
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU Affero General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU Affero General Public License for more details.
#
# You should have received a copy of the GNU Affero General Public License
# along with this program.  If not, see <http://www.gnu.org/licenses/>.

"""
This module contains the following classes:

* :class:`~aeneas.synthesizer.Synthesizer`,
  for synthesizing text fragments into an audio file,
  along with the corresponding time anchors.

.. warning:: This module might be refactored in a future version
"""

import logging
import os.path

from aeneas.runtimeconfiguration import RuntimeConfiguration
from aeneas.textfile import TextFile
from aeneas.ttswrappers.basettswrapper import BaseTTSWrapper
from aeneas.ttswrappers.espeakngttswrapper import ESPEAKNGTTSWrapper
from aeneas.ttswrappers.espeakttswrapper import ESPEAKTTSWrapper
from aeneas.ttswrappers.festivalttswrapper import FESTIVALTTSWrapper

logger = logging.getLogger(__name__)


class Synthesizer:
    """
    A class to synthesize text fragments into an audio file,
    along with the corresponding time anchors.
    """

    ESPEAK = "espeak"
    """ Select eSpeak wrapper """

    ESPEAKNG = "espeak-ng"
    """ Select eSpeak NG wrapper """

    FESTIVAL = "festival"
    """ Select Festival wrapper """

    ALLOWED_VALUES = (ESPEAK, ESPEAKNG, FESTIVAL)
    """ List of all the allowed values """

    def __init__(self, tts_engine: BaseTTSWrapper):
        self.tts_engine = tts_engine

    @classmethod
    def from_rconf(cls, rconf: RuntimeConfiguration):
        match rconf[RuntimeConfiguration.TTS]:
            case cls.ESPEAK:
                tts_cls: type[BaseTTSWrapper] = ESPEAKTTSWrapper
            case cls.ESPEAKNG:
                tts_cls = ESPEAKNGTTSWrapper
            case cls.FESTIVAL:
                tts_cls = FESTIVALTTSWrapper
            case _ as other:
                raise ValueError(f"Invalid TTS engine type {other!r}")

        return cls(tts_cls(rconf=rconf))

    @property
    def output_audio_format(self) -> tuple[str, int, int]:
        """
        Return a tuple ``(codec, channels, rate)``
        specifying the audio format
        generated by the actual TTS engine.

        :rtype: tuple
        """
        return self.tts_engine.OUTPUT_AUDIO_FORMAT

    def clear_cache(self):
        """
        Clear the TTS cache, removing all cache files from disk.

        .. versionadded:: 1.6.0
        """
        self.tts_engine.clear_cache()

    def synthesize(
        self,
        text_file: TextFile,
        audio_file_path: str,
        quit_after=None,
        backwards=False,
    ):
        """
        Synthesize the text contained in the given fragment list
        into a ``wav`` file.

        Return a tuple ``(anchors, total_time, num_chars)``.

        :param text_file: the text file to be synthesized
        :type  text_file: :class:`~aeneas.textfile.TextFile`
        :param string audio_file_path: the path to the output audio file
        :param float quit_after: stop synthesizing as soon as
                                 reaching this many seconds
        :param bool backwards: if ``True``, synthesizing from the end of the text file
        :rtype: tuple
        :raises: TypeError: if ``text_file`` is ``None`` or not an instance of ``TextFile``
        """
        if text_file is None:
            raise TypeError("`text_file` is None")
        if not isinstance(text_file, TextFile):
            raise TypeError("`text_file` is not an instance of TextFile")

        # synthesize
        logger.debug("Synthesizing text...")
        result = self.tts_engine.synthesize_multiple(
            text_file=text_file,
            output_file_path=audio_file_path,
            quit_after=quit_after,
            backwards=backwards,
        )
        logger.debug("Synthesizing text... done")

        # check that the output file has been written
        if not os.path.isfile(audio_file_path):
            raise OSError(f"Audio file path {audio_file_path!r} cannot be read")

        return result
