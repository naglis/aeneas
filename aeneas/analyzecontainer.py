# aeneas is a Python/C library and a set of tools
# to automagically synchronize audio and text (aka forced alignment)
#
# Copyright (C) 2012-2013, Alberto Pettarin (www.albertopettarin.it)
# Copyright (C) 2013-2015, ReadBeyond Srl   (www.readbeyond.it)
# Copyright (C) 2015-2017, Alberto Pettarin (www.albertopettarin.it)
#
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU Affero General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU Affero General Public License for more details.
#
# You should have received a copy of the GNU Affero General Public License
# along with this program.  If not, see <http://www.gnu.org/licenses/>.

"""
This module contains the following classes:

* :class:`~aeneas.analyzecontainer.AnalyzeContainer`
  implementing functions to analyze a given container
  and build the corresponding job object.

.. warning:: This module might be refactored in a future version
"""

import logging
import os
import re
import typing

from aeneas.container import Container
from aeneas.hierarchytype import HierarchyType
from aeneas.job import Job
from aeneas.logger import Configurable
from aeneas.task import Task
import aeneas.globalconstants as gc
import aeneas.globalfunctions as gf

logger = logging.getLogger(__name__)


class TaskInfo(typing.NamedTuple):
    custom_id: str
    text_path: str
    audio_path: str


class AnalyzeContainer(Configurable):
    """
    Analyze a given container and build the corresponding job.

    :param container: the container to be analyzed
    :type  container: :class:`~aeneas.container.Container`
    :param rconf: a runtime configuration
    :type  rconf: :class:`~aeneas.runtimeconfiguration.RuntimeConfiguration`
    """

    def __init__(self, container: Container, rconf=None):
        super().__init__(rconf=rconf)
        self.container = container

    def analyze(self, config_string: str | None = None) -> Job | None:
        """
        Analyze the given container and
        return the corresponding job object.

        On error, it will return ``None``.

        :param string config_string: the configuration string generated by wizard
        :rtype: :class:`~aeneas.job.Job` or ``None``
        """
        try:
            if config_string is not None:
                logger.debug("Analyzing container with the given config string")
                return self._analyze_txt_config(config_string=config_string)
            elif self.container.has_config_xml:
                logger.debug("Analyzing container with XML config file")
                return self._analyze_xml_config(config_contents=None)
            elif self.container.has_config_txt:
                logger.debug("Analyzing container with TXT config file")
                return self._analyze_txt_config(config_string=None)
            else:
                logger.debug("No configuration file in this container, returning None")
        except (OSError, KeyError, TypeError):
            logger.exception("An unexpected error occurred while analyzing")
        return None

    def _analyze_txt_config(self, config_string: str | None = None) -> Job:
        """
        Analyze the given container and return the corresponding job.

        If ``config_string`` is ``None``,
        try reading it from the TXT config file inside the container.

        :param string config_string: the configuration string
        :rtype: :class:`~aeneas.job.Job`
        """
        logger.debug("Analyzing container with TXT config string")

        if config_string is None:
            logger.debug("Analyzing container with TXT config file")
            config_entry = self.container.entry_config_txt
            logger.debug("Found TXT config entry %r", config_entry)
            config_dir = os.path.dirname(config_entry)
            logger.debug("Directory of TXT config entry: %r", config_dir)
            logger.debug("Reading TXT config entry: %r", config_entry)
            config_contents = self.container.read_entry(config_entry)
            logger.debug("Converting config contents to config string")
            config_contents = gf.safe_unicode(config_contents)
            config_string = gf.config_txt_to_string(config_contents)
        else:
            logger.debug("Analyzing container with TXT config string %r", config_string)
            config_dir = ""

        logger.debug("Creating the Job object")
        job = Job(config_string)

        logger.debug("Getting entries")
        entries = self.container.entries

        logger.debug("Converting config string into config dict")
        parameters = gf.config_string_to_dict(config_string)

        logger.debug("Calculating the path of the tasks root directory")
        tasks_root_directory = gf.norm_join(
            config_dir, parameters[gc.PPN_JOB_IS_HIERARCHY_PREFIX]
        )
        logger.debug("Path of the tasks root directory: %r", tasks_root_directory)

        logger.debug("Calculating the path of the sync map root directory")
        sync_map_root_directory = gf.norm_join(
            config_dir, parameters[gc.PPN_JOB_OS_HIERARCHY_PREFIX]
        )
        job_os_hierarchy_type = parameters[gc.PPN_JOB_OS_HIERARCHY_TYPE]
        logger.debug("Path of the sync map root directory: %r", sync_map_root_directory)

        text_file_relative_path = parameters[gc.PPN_JOB_IS_TEXT_FILE_RELATIVE_PATH]
        logger.debug("Relative path for text file: %r", text_file_relative_path)
        text_file_name_regex = re.compile(
            parameters[gc.PPN_JOB_IS_TEXT_FILE_NAME_REGEX]
        )
        logger.debug(
            "Regex for text file: %r",
            parameters[gc.PPN_JOB_IS_TEXT_FILE_NAME_REGEX],
        )
        audio_file_relative_path = parameters[gc.PPN_JOB_IS_AUDIO_FILE_RELATIVE_PATH]
        logger.debug("Relative path for audio file: %r", audio_file_relative_path)
        audio_file_name_regex = re.compile(
            parameters[gc.PPN_JOB_IS_AUDIO_FILE_NAME_REGEX]
        )
        logger.debug(
            "Regex for audio file: %r",
            parameters[gc.PPN_JOB_IS_AUDIO_FILE_NAME_REGEX],
        )

        if parameters[gc.PPN_JOB_IS_HIERARCHY_TYPE] == HierarchyType.FLAT:
            logger.debug("Looking for text/audio pairs in flat hierarchy")
            text_files = self._find_files(
                entries,
                tasks_root_directory,
                text_file_relative_path,
                text_file_name_regex,
            )
            logger.debug("Found text files: %r", text_files)
            audio_files = self._find_files(
                entries,
                tasks_root_directory,
                audio_file_relative_path,
                audio_file_name_regex,
            )
            logger.debug("Found audio files: %r", audio_files)

            for task_info in self._match_files_flat_hierarchy(text_files, audio_files):
                logger.debug("Creating task: %r", task_info)
                job.add_task(
                    self._create_task(
                        task_info,
                        config_string,
                        sync_map_root_directory,
                        job_os_hierarchy_type,
                    )
                )

        if parameters[gc.PPN_JOB_IS_HIERARCHY_TYPE] == HierarchyType.PAGED:
            logger.debug("Looking for text/audio pairs in paged hierarchy")
            # find all subdirectories of tasks_root_directory
            # that match gc.PPN_JOB_IS_TASK_DIRECTORY_NAME_REGEX
            matched_directories = self._match_directories(
                entries,
                tasks_root_directory,
                parameters[gc.PPN_JOB_IS_TASK_DIRECTORY_NAME_REGEX],
            )
            for matched_directory in matched_directories:
                # rebuild the full path
                matched_directory_full_path = gf.norm_join(
                    tasks_root_directory, matched_directory
                )
                logger.debug(
                    "Looking for text/audio pairs in directory %r",
                    matched_directory_full_path,
                )

                # look for text and audio files there
                text_files = self._find_files(
                    entries,
                    matched_directory_full_path,
                    text_file_relative_path,
                    text_file_name_regex,
                )
                logger.debug("Found text files: %r", text_files)
                audio_files = self._find_files(
                    entries,
                    matched_directory_full_path,
                    audio_file_relative_path,
                    audio_file_name_regex,
                )
                logger.debug("Found audio files: %r", audio_files)

                # if we have found exactly one text and one audio file,
                # create a Task
                if len(text_files) == 1 and len(audio_files) == 1:
                    logger.debug(
                        "Exactly one text file and one audio file in %r",
                        matched_directory,
                    )
                    task_info = TaskInfo(
                        matched_directory, text_files[0], audio_files[0]
                    )
                    logger.debug("Creating task: %r", task_info)
                    job.add_task(
                        self._create_task(
                            task_info,
                            config_string,
                            sync_map_root_directory,
                            job_os_hierarchy_type,
                        )
                    )
                elif len(text_files) > 1:
                    logger.debug("More than one text file in %r", matched_directory)
                elif len(audio_files) > 1:
                    logger.debug("More than one audio file in %r", matched_directory)
                else:
                    logger.debug("No text nor audio file in %r", matched_directory)

        return job

    def _analyze_xml_config(self, config_contents: str | None = None) -> Job:
        """
        Analyze the given container and return the corresponding job.

        If ``config_contents`` is ``None``,
        try reading it from the XML config file inside the container.

        :param string config_contents: the contents of the XML config file
        :rtype: :class:`~aeneas.job.Job`
        """
        logger.debug("Analyzing container with XML config string")

        if config_contents is None:
            logger.debug("Analyzing container with XML config file")
            config_entry = self.container.entry_config_xml
            logger.debug("Found XML config entry %r", config_entry)
            config_dir = os.path.dirname(config_entry)
            logger.debug("Directory of XML config entry: %r", config_dir)
            logger.debug("Reading XML config entry: %r", config_entry)
            config_contents = self.container.read_entry(config_entry)
        else:
            logger.debug("Analyzing container with XML config contents")
            config_dir = ""

        logger.debug("Converting config contents into job config dict")
        job_parameters = gf.config_xml_to_dict(
            config_contents, result=None, parse_job=True
        )
        logger.debug("Converting config contents into tasks config dict")
        tasks_parameters = gf.config_xml_to_dict(
            config_contents, result=None, parse_job=False
        )

        logger.debug("Calculating the path of the sync map root directory")
        sync_map_root_directory = gf.norm_join(
            config_dir, job_parameters[gc.PPN_JOB_OS_HIERARCHY_PREFIX]
        )
        job_os_hierarchy_type = job_parameters[gc.PPN_JOB_OS_HIERARCHY_TYPE]
        logger.debug("Path of the sync map root directory: %r", sync_map_root_directory)

        logger.debug("Converting job config dict into job config string")
        config_string = gf.config_dict_to_string(job_parameters)
        job = Job(config_string)

        for task_parameters in tasks_parameters:
            config_string = gf.config_dict_to_string(task_parameters)
            logger.debug("Creating task with config string %r", config_string)
            custom_id = task_parameters.get(gc.PPN_TASK_CUSTOM_ID, "")
            task_info = TaskInfo(
                custom_id,
                gf.norm_join(config_dir, task_parameters[gc.PPN_TASK_IS_TEXT_FILE_XML]),
                gf.norm_join(
                    config_dir, task_parameters[gc.PPN_TASK_IS_AUDIO_FILE_XML]
                ),
            )
            logger.debug("Creating task: %r", task_info)
            job.add_task(
                self._create_task(
                    task_info,
                    config_string,
                    sync_map_root_directory,
                    job_os_hierarchy_type,
                )
            )

        return job

    def _create_task(
        self,
        task_info: TaskInfo,
        config_string: str,
        sync_map_root_directory: str,
        job_os_hierarchy_type,
    ) -> Task:
        """
        Create a task object from

        1. the ``task_info`` found analyzing the container entries, and
        2. the given ``config_string``.

        :param list task_info: the task information: ``[prefix, text_path, audio_path]``
        :param string config_string: the configuration string
        :param string sync_map_root_directory: the root directory for the sync map files
        :param job_os_hierarchy_type: type of job output hierarchy
        :type  job_os_hierarchy_type: :class:`~aeneas.hierarchytype.HierarchyType`
        :rtype: :class:`~aeneas.task.Task`
        """
        parameters = gf.config_string_to_dict(config_string)
        task = Task(config_string)
        task.configuration["description"] = f"Task {task_info.custom_id}"
        logger.debug("Task description: %s", task.configuration["description"])
        try:
            task.configuration["language"] = parameters[gc.PPN_TASK_LANGUAGE]
            logger.debug("Set language from task: %r", task.configuration["language"])
        except KeyError:
            task.configuration["language"] = parameters[gc.PPN_JOB_LANGUAGE]
            logger.debug("Set language from job: %r", task.configuration["language"])
        task.configuration["custom_id"] = task_info.custom_id
        logger.debug("Task custom_id: %s", task_info.custom_id)
        task.text_file_path = task_info.text_path
        logger.debug("Task text file path: %s", task.text_file_path)
        task.audio_file_path = task_info.audio_path
        logger.debug("Task audio file path: %s", task.audio_file_path)
        task.sync_map_file_path = self._compute_sync_map_file_path(
            sync_map_root_directory,
            job_os_hierarchy_type,
            task_info.custom_id,
            task.configuration["o_name"],
        )
        logger.debug("Task sync map file path: %s", task.sync_map_file_path)

        logger.debug("Replacing placeholder in os_file_smil_audio_ref")
        task.configuration["o_smil_audio_ref"] = self._replace_placeholder(
            task.configuration["o_smil_audio_ref"], task_info.custom_id
        )
        logger.debug("Replacing placeholder in os_file_smil_page_ref")
        task.configuration["o_smil_page_ref"] = self._replace_placeholder(
            task.configuration["o_smil_page_ref"], task_info.custom_id
        )
        return task

    def _replace_placeholder(self, string: str, custom_id: str) -> str:
        """
        Replace the prefix placeholder
        :class:`~aeneas.globalconstants.PPV_OS_TASK_PREFIX`
        with ``custom_id`` and return the resulting string.

        :rtype: string
        """
        logger.debug(
            "Replacing %r with %r in %r",
            gc.PPV_OS_TASK_PREFIX,
            custom_id,
            string,
        )
        return string.replace(gc.PPV_OS_TASK_PREFIX, custom_id)

    def _compute_sync_map_file_path(
        self, root: str, hierarchy_type, custom_id: str, file_name: str
    ) -> str:
        """
        Compute the sync map file path inside the output container.

        :param string root: the root of the sync map files inside the container
        :param job_os_hierarchy_type: type of job output hierarchy
        :type  job_os_hierarchy_type: :class:`~aeneas.hierarchytype.HierarchyType`
        :param string custom_id: the task custom id (flat) or
                                 page directory name (paged)
        :param string file_name: the output file name for the sync map
        :rtype: string
        """
        prefix = root
        if hierarchy_type == HierarchyType.PAGED:
            prefix = gf.norm_join(prefix, custom_id)
        file_name_joined = gf.norm_join(prefix, file_name)
        return self._replace_placeholder(file_name_joined, custom_id)

    def _find_files(
        self,
        entries: list[str],
        root: str,
        relative_path: str | None,
        file_name_regex: re.Pattern[str],
    ) -> list[str]:
        """
        Return the elements in entries that

        1. are in ``root/relative_path``, and
        2. match ``file_name_regex``.

        :param list entries: the list of entries (file paths) in the container
        :param string root: the root directory of the container
        :param string relative_path: the relative path in which we must search
        :param regex file_name_regex: the regex matching the desired file names
        :rtype: list of strings (path)
        """

        target = root
        if relative_path is not None:
            target = gf.norm_join(root, relative_path)

        logger.debug("Finding files within target: %r", target)
        files = []
        target_len = len(target)
        for entry in entries:
            if not entry.startswith(target):
                continue

            entry_suffix = entry[target_len + 1 :]
            if file_name_regex.search(entry_suffix):
                files.append(entry)

        return sorted(files)

    def _match_files_flat_hierarchy(
        self, text_files, audio_files
    ) -> typing.Iterator[TaskInfo]:
        """
        Match audio and text files in flat hierarchies.

        Two files match if their names,
        once removed the file extension,
        are the same.

        Examples: ::

            foo/text/a.txt foo/audio/a.mp3 => match: ["a", "foo/text/a.txt", "foo/audio/a.mp3"]
            foo/text/a.txt foo/audio/b.mp3 => no match
            foo/res/c.txt  foo/res/c.mp3   => match: ["c", "foo/res/c.txt", "foo/res/c.mp3"]
            foo/res/d.txt  foo/res/e.mp3   => no match

        :param list text_files: the entries corresponding to text files
        :param list audio_files: the entries corresponding to audio files
        :rtype: iterator of TaskInfo
        """
        logger.debug(
            "Matching text files %r and audio files %r in flat hierarchy",
            text_files,
            audio_files,
        )

        d_text = {
            gf.file_name_without_extension(text_file): text_file
            for text_file in text_files
        }
        d_audio = {
            gf.file_name_without_extension(audio_file): audio_file
            for audio_file in audio_files
        }

        for key in d_text:
            if key not in d_audio:
                continue

            yield TaskInfo(key, d_text[key], d_audio[key])

    def _match_directories(
        self, entries: list[str], root: str, regex_string: str
    ) -> list[str]:
        """
        Match directory names in paged hierarchies.

        Example: ::

            root = /foo/bar
            regex_string = [0-9]+

            /foo/bar/
                     1/
                       bar
                       baz
                     2/
                       bar
                     3/
                       foo

            => ["/foo/bar/1", "/foo/bar/2", "/foo/bar/3"]

        :param list entries: the list of entries (paths) of a container
        :param string root: the root directory to search within
        :param string regex_string: regex string to match directory names
        :rtype: list of matched directories
        """
        logger.debug(
            "Matching directory names based on regex %r in paged hierarchy within %r",
            regex_string,
            root,
        )
        regex = re.compile(regex_string)
        directories = set()
        root_len = len(root)
        for entry in entries:
            # look only inside root dir
            if not entry.startswith(root):
                continue

            logger.debug("Examining %r", entry)
            # remove common prefix root/
            entry = entry[root_len + len(os.sep) :]
            # split path
            entry_splitted = entry.split(os.sep)
            # match regex
            if len(entry_splitted) >= 2 and regex.match(entry_splitted[0]):
                directories.add(entry_splitted[0])
                logger.debug("Match: %r", entry_splitted[0])
            else:
                logger.debug("No match: %r", entry)

        return sorted(directories)
